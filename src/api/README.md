## 请求的取消问题

### 在单页应用中，如果路由离开，该路由发出正在排队的、正在传输的请求，还是会继续发送。

> 需要依托于路由守卫，当路由变化的时候，把不属于当前路由的请求取消

1. 拦截器，要为设置一个 map 队列，每个请求进入的时候，都记录（用路由作为 key）
2. 把这个内存的 map 对象共享出去，在路由拦截中，具体做取消请求动作（具体的取消方法也要暴露出去）
3. 默认都做这个取消动作，通过配置项，在单独的请求里，取消这个默认行为

### 相同请求，新的比老的优先返回，造成渲染错误的情况

> 接着上面的思路

1. 在请求拦截器中(同一路由下)，当请求进来，如果队列里有相同请求，永远用新的替换老的
2. 老的就算再请求中，也要取消，一起被替换
3. 这个配置一刀切，要么全这样，要么不启用
